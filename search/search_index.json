{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Welcome to Slacker","text":"<p>Slacker (aka JinSlacker) sends messages from AWS services to Slack. It supports dynamic time-of-day and content based filtering, rewriting and routing of messages.</p> <p>Slacker has been used extensively in a large, business critical data warehouse / data lake environment.</p> Turn this ...Into this ... <p> </p> <p> </p> <p>More ...</p> <p>Slacker was developed at Origin Energy as part of the Jindabyne initiative. While not part of our core IP, it proved valuable internally, and we're sharing it in the hope it's useful to others.</p> <p></p> <p>Kudos to Origin for fostering a culture that empowers its people to build complex technology solutions in-house.</p>"},{"location":"01-overview.html","title":"Overview","text":"<p>Slacker was developed at Origin Energy as part of the Jindabyne initiative. While not part of our core IP, it proved valuable internally, and we're sharing it in the hope it's useful to others.</p> <p></p> <p>Kudos to Origin for fostering a culture that empowers its people to build complex technology solutions in-house.</p> <p>Slacker (aka JinSlacker) sends messages from AWS services to Slack channels.</p> <p>This is hardly revolutionary, and there are other mechanisms to achieve this in an AWS environment. These mechanisms are fine if you're happy with limited control of where messages can come from or go to, as well as having your Slack channels filling up with the incomprehensible gibberish produced in a typical AWS environment.</p> <p>Slacker supports a number of capabilities to address these challenges:</p> <ul> <li>Message content analysis using regular expressions and JSON parsing</li> <li>Message routing and filtering based on message source, content, and time of day</li> <li>Message content rewriting using     Jinja templates.</li> </ul> <p>Currently supported AWS sources are:</p> <ul> <li>SNS</li> <li>CloudWatch logs</li> <li>Amazon EventBridge</li> <li>Direct invocation.</li> </ul> <p>What about AWS Chatbot?</p> <p>AWS Chatbot can also integrate with Slack. Unlike slacker, it also has some limited interactive capability.</p> <p>Subjectivity warning ...</p> <p>Slacker is much more flexible in it's ability to do dynamic content analysis, and message routing and rewriting. We also believe slacker is simpler to deploy and use. We'd argue that the interactive capabilities of the AWS Chatbot solution are so limited by the (essential) security restrictions as to be of marginal value in a real operational environment.</p>"},{"location":"02-how-it-works.html","title":"How it Works","text":"<p>Slacker has a minimal AWS footprint, consisting of a Python-based AWS Lambda function and two small DynamoDB tables. It includes a CLI to test, validate and manage configuration data held in the DynamoDB tables.</p> <p>It uses Slack's incoming webhook mechanism to send messages.</p> <p>Note</p> <p>Slack webhooks are a legacy integration method but they work just fine.</p> <p>The architecture is simple:</p> <p></p> <p>Notes</p> <ol> <li>The slacker Lambda does not need to run within a VPC.</li> <li>EventBridge can send messages to slacker, either directly or via SNS.</li> </ol>"},{"location":"02-how-it-works.html#the-sending-process","title":"The Sending Process","text":"<p>The sending process is:</p> <ol> <li> <p>Message Publishing</p> <p>A message is published by the originating AWS source (e.g. SNS) to the slacker Lambda function.</p> </li> <li> <p>Slack Webhook Lookup</p> <p>Slacker looks up the source ID (e.g. SNS topic ARN) in the DynamoDB webhooks table and obtains the URL of the Slack webhook and some other control information. If the source ID is not found in the webhooks table, the wildcard webhook is used, if present.</p> </li> <li> <p>Rules Processing</p> <p>Slacker processes the message against any rules specified in the webhooks table table to decide if the message should be discarded, diverted, or modified prior to sending.</p> </li> <li> <p>Message Sending</p> <p>Slacker uses the webhook URL to send the message to Slack.</p> </li> </ol>"},{"location":"02-how-it-works.html#the-webhooks-table","title":"The Webhooks Table","text":"<p>The webhooks table is a DynamoDB table named <code>slacker.webhooks</code>. It maps AWS message source IDs to Slack webhook URLs. All sources feeding messages to slacker must have an entry in the table.</p> <p>Note</p> <p>The name of the table made more sense when slacker was young. Stuck with it now.</p> <p>The table must be created with <code>sourceId</code> as the primary partition key. The table is created as part of a standard installation.</p> <p>The table contains the following fields.</p> Name Required Type Description #... No Any Any field with a name starting with <code>#</code> is treated as a comment and ignored by slacker. account Note 1 String The AWS account ID into which the webhook is deployed. channel Note 2 String An alias for a Slack webhook URL that will be looked up in the channels table. This can be overridden in individual message rules to redirect a message. colour No String Slack messages will have a colour bar displayed down the left margin specified by the value of this field. This can be any hex colour code (prefixed with <code>#</code>), or one of the Slack special values <code>good</code>, <code>warning</code>, or <code>danger</code>. The default value is a light grey <code>#bbbbbb</code> unless overridden by the <code>SLACKER_COLOUR</code> environment variable. enabled No boolean If <code>false</code>, sending from this source to Slack is disabled. Default is <code>true</code>. preamble No String A fixed text preamble for all messages. The most useful values are things such as <code>&lt;!here&gt;</code> and <code>&lt;!channel&gt;</code> which will cause Slack to insert <code>@here</code> and <code>@channel</code> alert tags respectively. rules No List A list of rules that can control whether a message is sent, or not, and the content of the message. See Message Rules. sourceId Yes String The source ID for the AWS message source. See Message Sources below. url Note 2 String The full URL of the Slack webhook. Deprecated. Use <code>channel</code> instead. x-* No Any Any field with a name starting with <code>x-</code> / <code>X-</code> is ignored. These can be used for metadata for things such as CI/CD tools. <p>Notes</p> <ol> <li> <p>The <code>account</code> field is not used by the slacker Lambda function. It is used     by the slacker CLI to ensure that webhook entries are not     accidentally deployed into the wrong account.</p> </li> <li> <p>One of <code>channel</code> (preferred) and <code>url</code> must be specified. </p> </li> <li> <p>Slacker caches webhook entries for 5 minutes. Table updates can take this     amount of time to become effective. The duration can be changed by setting     the <code>SLACKER_CACHE_TTL</code> environment     variable.</p> </li> </ol> <p>Tip</p> <p>A JSON schema definition is available for webhooks table entries. Some IDEs (e.g. the JetBrains suite) will use the schema definition to provide auto-completion, dynamic validation etc. </p> <p>To use it, include the following element in entries:</p> YAMLJSON <pre><code>$schema: https://jin-gizmo.github.io/slacker/schemas/latest/webhook.schema.json\nsourceID: ...\n</code></pre> <p>Replace <code>latest</code> with <code>vN</code> (e.g. <code>v2</code>) to get a versioned schema.</p> <pre><code>{\n    \"$schema\": \"https://jin-gizmo.github.io/slacker/schemas/latest/webhook.schema.json\",\n    \"sourceId\": \"...\"\n}\n</code></pre> <p>Replace <code>latest</code> with <code>vN</code> (e.g. <code>v2</code>) to get a versioned schema.</p> <p>Note that the slacker CLI will add the <code>$schema</code> entry when downloading from DynamoDB and strip it when deploying to DynamoDB.</p>"},{"location":"02-how-it-works.html#the-channels-table","title":"The Channels Table","text":"<p>The channels table is a DynamoDB table called <code>slacker.channels</code>. It provides an arbitrary alias for Slack webhooks. The <code>channel</code> field in a webhooks table entry is used to obtain the actual Slack webhook URL from the channels table.</p> <p>The channel can be the Slack channel name corresponding to a given webhook, but it does not have to be. An alternative scheme could, for example, use functional labels such as <code>priority-1-alerts</code> as the channel alias. Slack itself only ever knows about the webhook URL.</p> <p>The channels table contains the following fields.</p> Name Required Type Description #... No Any Any field with a name starting with <code>#</code> is treated as a comment and ignored by slacker. channel Yes String An alias for a Slack webhook URL. This can be referenced in the webhooks table. url Yes String The full URL of the Slack webhook. x-* No Any Any field with a name starting with <code>x-</code> / <code>X-</code> is ignored. These can be used for metadata for things such as CI/CD tools. <p>Note</p> <p>Slacker caches channel entries for 5 minutes. Table updates can take this amount of time to become effective. The duration can be changed by setting the <code>SLACKER_CACHE_TTL</code> environment variable.</p> <p>Tip</p> <p>A JSON schema definition is also available for channels table entries. although the entries are so simple that it's hardly worth the bother.</p> <p>For what it's worth, to use it, include the following element in entries:</p> YAMLJSON <pre><code>$schema: https://jin-gizmo.github.io/slacker/schemas/latest/channel.schema.json\nchannel: ...\n</code></pre> <p>Replace <code>latest</code> with <code>vN</code> (e.g. <code>v2</code>) to get a versioned schema.</p> <pre><code>{\n    \"$schema\": \"https://jin-gizmo.github.io/slacker/schemas/latest/channel.schema.json\",\n    \"channel\": \"...\"\n}\n</code></pre> <p>Replace <code>latest</code> with <code>vN</code> (e.g. <code>v2</code>) to get a versioned schema.</p>"},{"location":"02-how-it-works.html#message-sources","title":"Message Sources","text":"<p>See also Adding Message Sources.</p> <p>Incoming messages may come from a number of sources. Slacker needs to identify the source to determine the processing and routing rules that should be applied.</p> <p>The value of the <code>sourceId</code> field of the webhooks table is used to select the appropriate rule set. It is dependent on the source type.</p> Source Value of <code>sourceId</code> CloudWatch Logs <code>logs:</code> followed by the log group name (e.g. <code>logs:/var/log/messages</code>). SNS SNS topic ARN. Amazon EventBridge (via SNS) SNS topic ARN. Amazon EventBridge (direct, no input transform) <code>events:</code> followed by the <code>source</code> field from the event message (e.g. <code>events:aws.rds</code>) Amazon EventBridge (direct, with input transform) Value of the <code>SlackerSourceId</code> field in the constructed message. Direct Invocation Value of the <code>SlackerSourceId</code> field in the input message."},{"location":"02-how-it-works.html#message-rules","title":"Message Rules","text":"<p>A webhooks table entry may contain a <code>rules</code> key that can filter and reformat messages.</p> <p>If there is no <code>rules</code> key, messages are sent to Slack, unfiltered and unmodified.</p> <p>If present, the <code>rules</code> key contains a list of individual rules that are processed in order. The first matching rule decides the treatment of the message and the subsequent rules are ignored. If no rules match a message, the message is sent to Slack unmodified.</p> <p>Tip</p> <p>Slacker's fallback position is to always deliver the message to Slack unless a correctly operating rule directs some other action. This means that errors in rules are generally not serious. It also means that rule sets can start out simple (or empty!) and be augmented over time.</p> <p>Messages sent to slacker from AWS related events are of two kinds.</p> <ol> <li>Object messages: These are JSON encoded objects. Slacker will decode     the JSON into an object when processing the rules. The attributes of the     object are then available for use in Jinja rendered constructs for message     filtering and reformatting.</li> <li>Text messages: These are arbitrary text messages. Slacker can     optionally apply a     Python regex     containing capture groups to these messages to extract named attributes for     use in Jinja rendered constructs for message filtering and reformatting.</li> </ol> <p>Each rule is an object (dictionary) that may contain the following keys:</p> Key Description #... Any field with a name starting with <code>#</code> is treated as a comment and ignored by slacker. action The action to take if the rule selects the message. Possible values are <code>drop</code> (discard the message) and <code>send</code>. The default is <code>send</code>. channel If the rule selects the message, override the channel to which the message is sent. colour If the rule selects the message, override the default colour for the Slack sidebar. if A Jinja template that is rendered using the attributes from an object message or the regex capture groups matched from a text message to produce a truthy value. If the truthy value is true, the rule applies to the message, otherwise the rule is skipped. match A regex that will be applied to text messages using Python's <code>re.search()</code>. If the message is an object message or does not match the regex, the rule is skipped. The regex may contain named capture groups using the <code>(?P&lt;name&gt;...)</code> syntax in the regex. These are then made available as Jinja rendering variables for use in a <code>template</code> to produce a new message text. Slacker also populates the <code>msg</code> parameter with the full message text. preamble If the rule selects the message, override the default preamble for the Slack message. template A Jinja template used to generate the actual message to be sent to Slack. This is rendered with the attributes from an object message or the regex capture groups matched from a text message. If the rendering process fails for any reason (e.g. malformed Jinja), the rule is skipped. <p>Tip</p> <p>Rules can be tested locally using the slacker CLI.</p> <p>The rule processing flow is shown below:</p> <p></p>"},{"location":"02-how-it-works.html#jinja-rendering","title":"Jinja Rendering","text":"<p>These components of the message rules are Jinja rendered:</p> <ul> <li> <p><code>if</code> predicates used to determine whether or not the rule applies.</p> </li> <li> <p><code>template</code> specifications used to generate the content of the Slack message.</p> </li> </ul> <p>Slacker makes the following rendering parameters available:</p> Parameter Description aws A dictionary of AWS related helper utilities as follows... \u00a0\u00a0\u00a0\u00a0aws.account_id The AWS account ID. \u00a0\u00a0\u00a0\u00a0aws.Arn A class that takes an ARN and makes the individual components available as the following attributes: <code>partition</code>, <code>service</code>, <code>region</code>, <code>account</code>, <code>resource</code>. e.g. <code>{{ aws.Arn(\"arn:aws:sns:us-east-1:123456789012:xyzzy\").region }}</code> is <code>us-east-1</code>. data Dictionary containing attributes extracted from the source message by a <code>match</code> regex applied to a text message or the decoded content of an object message. datetime The Python <code>datetime.datetime</code> module. date The Python <code>datetime.date</code> module. msg The original source message string. now A function that takes an optional timezone name (default <code>UTC</code>) and returns a timezone aware Python datetime object. e.g. <code>now()</code> or <code>now('Australia/Melbourne')</code>. re The Python <code>re</code> (regex) module. time_of_day A function that takes an optional timezone name (default <code>UTC</code>) and returns the current time as a string of the form <code>HH:MM:SS</code>. e.g. <code>current_time('UTC')</code> or <code>current_time('Australia/Melbourne')</code>. tz The python <code>ZoneInfo</code> module. e.g. <code>tz('Australia/Melbourne')</code>, <code>tz('UTC')</code>."},{"location":"02-how-it-works.html#the-wildcard-webhook","title":"The Wildcard Webhook","text":"<p>The wildcard webhook is a webhooks table entry with a <code>sourceId</code> of <code>*</code>.</p> <p>It has two roles:</p> <ol> <li> <p>Webhook of last resort: If an incoming message has a source ID that doesn't     match any entry in the webhooks table, the wildcard     webhook is used to process the message.</p> <p>Without a wildcard webhook, the message would otherwise be dropped.</p> </li> <li> <p>Container for common webhook rules: Any rules in the wildcard webhook     are implicitly appended to the rules of all other webhooks.</p> <p>This provides a single location for common rules that would otherwise need to be repeated in individual webhooks. Only the <code>rules</code> component of the wildcard webhook is used in this instance. Other fields are ignored.</p> </li> </ol> <p>Notes</p> <ol> <li>The wildcard webhook is optional. If there is no wildcard webhook,     incoming messages with an unmatched source ID will be dropped.</li> <li>To prevent a specific webhook from implicitly falling through to the     wildcard webhook rules, add an unqualified <code>send</code> (or <code>drop</code>) rule to     the end of the former's rule list.</li> </ol> <p>Tip</p> <p>A sample set of rules for the wildcard webhook is provided in the rule library.</p>"},{"location":"03-examples.html","title":"Examples","text":"<p>Note</p> <p>Examples are shown in YAML format for simplicity and because this is the preferred format when using the slacker CLI.</p> <p>Tip</p> <p>See also Rule Library for some real-world reusable rules.</p> <p>The simplest possible webhooks table item is like so:</p> <pre><code>account: '123456789012'\nchannel: channels-table-reference\nsourceId: 'arn:aws:sns:us-east-1:123456789012:my-topic'\n</code></pre> <p>This will pass all incoming messages on the specified SNS topic to the specified Slack channel, unmodified.</p> <p>Slacker gets more useful with the addition of message rules to filter or transform incoming messages. The following examples relate to the <code>rules</code> list attribute in webhooks table items.</p>"},{"location":"03-examples.html#text-message-examples","title":"Text Message Examples","text":"<p>Consider the following text message:</p> <pre><code>ERROR: The wheels have fallen off 3 little red wagons\n</code></pre> <p>The following rule set would force the message to be discarded (dropped):</p> <pre><code>account: ...\nchannel: ...\nsourceId: ...\nrules:\n  - '#': Comment -- ignored\n    match: '^ERROR:.*wagons$'\n    action: drop\n</code></pre> <p>The following rule set would:</p> <ul> <li>Discard messages about a small number of wagons suffering wheels detaching.</li> <li>Add different colour bars for more severe wheel loss on red and blue wagons     but send the message unmodified. Messages about blue wagons will be diverted     to a different Slack channel.</li> <li>Send a custom message for severe wheel loss on other coloured wagons.</li> </ul> <pre><code>account: ...\nchannel: ...\nsourceId: ...\nrules:\n  - match: '^ERROR:.* fallen off (?P&lt;count&gt;[0-9]+) little [a-z]+ wagons'\n    if: '{{ data.count | int &lt; 4 }}'\n    action: drop\n  - '#': This rule only reached for matching messages with wagon count &gt;= 4\n    match: '^ERROR:.* fallen off [0-9]+ little (?P&lt;colour&gt;[a-z]+) wagons'\n    if: '{{ data.colour == \"red\" }}'\n    colour: '#ff0000'\n    action: send\n  - '#': This rule for blue wagons has an implicit send action\n    match: '^ERROR:.* fallen off [0-9]+ little (?P&lt;colour&gt;[a-z]+) wagons'\n    if: '{{ data.colour == \"blue\" }}'\n    colour: '#0000ff'\n    channel: still-got-the-blues\n  - '#': This rule produces a custom message for odd colour wagons\n    match: '^ERROR:.* fallen off (?P&lt;count&gt;[0-9]+) little (?P&lt;colour&gt;[a-z]+) wagons'\n    template: |\n      WANTED: {{ data.count }} {{ data.colour }} wagons with wheels\n</code></pre>"},{"location":"03-examples.html#object-message-examples","title":"Object Message Examples","text":"<p>Consider the following message indicating the number, and colour, of wagons for which a wheel has fallen off.</p> <pre><code>{ \"event\": \"wheels off\", \"count\": 3, \"wagon_colour\": \"red\" }\n</code></pre> <p>This will be received by slacker as a string but will will be JSON decoded to an object.</p> <p>The following rule set would force the message above to be discarded:</p> <pre><code>account: ...\nchannel: ...\nsourceId: ...\nrules:\n  - '#': Comment -- ignored\n    if: '{{ event == \"wheels off\" and count | int &lt; 4 }}'\n    action: drop\n</code></pre> <p>The following rule set would:</p> <ul> <li>Discard messages about a small number of wagons suffering wheels detaching.</li> <li>Add different colour bars for more severe wheel loss on red and blue wagons     but send the message unmodified. Messages about blue wagons will be diverted     to a different Slack channel.</li> <li>Send a custom message for severe wheel loss on other coloured wagons.</li> </ul> <pre><code>account: ...\nchannel: ...\nsourceId: ...\nrules:\n  - if: '{{ data.event == \"wheels off\" and data.count | int &lt; 4 }}'\n    action: drop\n  - '#': This rule only reached for matching messages with wagon count &gt;= 4\n    if: '{{ data.event == \"wheels off\" and data.colour == \"red\" }}'\n    colour: '#ff0000'\n    action: send\n  - '#': This rule for blue wagons has an implicit send action\n    if: '{{ data.event == \"wheels off\" and data.colour == \"blue\" }}'\n    colour: '#0000ff'\n    channel: still-got-the-blues\n  - '#': This rule produces a custom message for odd colour wagons\n    if: '{{ data.event == \"wheels off\" }}'\n    template: |\n      WANTED: {{ data.count }} {{ data.colour }} wagons with wheels\n</code></pre> <p>The following rule set would format object messages nicely and pass other messages through unchanged.</p> <pre><code>account: ...\nchannel: ...\nsourceId: ...\nrules:\n  - template: |\n      ```\n      {{ data | tojson(4) }}\n      ```\n</code></pre> <p>The following rule set would discard messages sent between 5pm and 6pm Sydney time:</p> <pre><code>account: ...\nchannel: ...\nsourceId: ...\nrules:\n  - if: '{{ \"17:00:00\" &lt;= current_time(\"Australia/Sydney\") &lt;= \"18:00:00\" }}'\n    action: drop\n</code></pre>"},{"location":"04-installation-and-usage.html","title":"Installation and Usage","text":""},{"location":"04-installation-and-usage.html#prerequisites","title":"Prerequisites","text":"<p>Python 3.11+ is required for the slacker CLI. The slacker Lambda function uses the Python 3.13 runtime.</p> <p>The AWS components (slacker Lambda function, DynamoDB tables etc) are installed from the repo using AWS SAM. This will need to be installed first.</p> <p>SAM is not required for the slacker CLI.</p> <p>Editorial</p> <p>AWS SAM used to be installable from PyPI. It may be still, but AWS doesn't seem to support it. The rest of the world seem to manage OK(-ish) with PyPI for far more complex packages than SAM.  \u00af_(\u30c4)_/\u00af</p>"},{"location":"04-installation-and-usage.html#installing-the-slacker-aws-components","title":"Installing the Slacker AWS Components","text":"<p>With AWS SAM installed, the installation / update process for slacker is as follows:</p> <pre><code># Clone the repo and prepare the working area (create virtualenv etc)\ngit clone git@github.com:jin-gizmo/slacker.git\ncd slacker\nmake init\n\n# Activate the venv\nsource venv/bin/activate\n\n# Do a guided install.\nmake install\n</code></pre> <p>Note</p> <p>Slacker can be deployed in as many AWS regions and accounts as required.</p> <p>Info</p> <p>The CloudFormation stack name should be left as <code>slacker</code>, if at all possible. This affects the naming of the Lambda function and the DynamoDB tables, among other things.</p>"},{"location":"04-installation-and-usage.html#slacker-lambda-configuration-parameters","title":"Slacker Lambda Configuration Parameters","text":"<p>The guided install process prompts for any required configuration values. The defaults should be fine in most cases but this is what the less obvious ones relating to the CloudFormation stack mean:</p> Parameter Description defaultSideBarColour Slack messages will have a colour bar displayed down the left margin specified by the value of this field unless overridden for a given source ID in the webhooks table. This can be any hex colour code (prefixed with <code>#</code>), or one of the Slack special values <code>good</code>, <code>warning</code>, or <code>danger</code>. This parameter sets the <code>SLACKER_COLOUR</code> environment variable for the Lambda function. dynamoDbReadCapacity Read capacity units for the DynamoDB table. The default is 5. While this seems quite low, it should be adequate in most environments as a result of caching in the slacker Lambda. maxMessageLen The maximum length in bytes of messages sent to Slacker. Longer messages are truncated. This parameter sets the <code>SLACKER_MSG_LEN</code> environment variable for the Lambda function. <p>Other stack parameters are self-explanatory.</p>"},{"location":"04-installation-and-usage.html#logging","title":"Logging","text":"<p>If slacker is configured to log messages in CloudWatch, the log entries look like this:</p> <pre><code>{\n  \"message\": \"...\",\n  \"sourceId\": \"arn:aws:sns:us-east-1:...\",\n  \"sourceName\": \"SNS:...\",\n  \"subject\": \"Whatever\",\n  \"timestamp\": 1749106337.055,\n  \"type\": \"incoming\"\n}\n</code></pre>"},{"location":"04-installation-and-usage.html#slacker-lambda-environment-variables","title":"Slacker Lambda Environment Variables","text":"<p>The slacker Lambda supports the following environment variables.</p> Name Description Default LOGLEVEL One of the standard Python logging levels (<code>debug</code>, <code>info</code>, ...). <code>info</code> LOG_MESSAGES If set to <code>1</code>, log messages to CloudWatch prior to processing. <code>0</code> SLACKER_COLOUR The default colour for the bar on the left hand margin of messages sent to Slack unless overridden for a given source ID in the webhooks table. This can be any hex colour code or one of the Slack special values <code>good</code>, <code>warning</code> or <code>danger</code>. <code>#bbbbbb</code> SLACKER_MSG_LEN The maximum length in bytes of messages sent to Slacker. Longer messages are truncated. 4000 SLACKER_CACHE_TTL Number of seconds to cache lookups from the DynamoDB tables. 300"},{"location":"04-installation-and-usage.html#the-slacker-cli","title":"The Slacker CLI","text":"<p>The slacker CLI is installed with pip:</p> <p><pre><code>pip install jinslacker\nslacker --help\n</code></pre> It can also be built from the repo:</p> <pre><code># Output is in dist/pkg directory\nmake pkg\n</code></pre>"},{"location":"04-installation-and-usage.html#slacker-cli-environment-variables","title":"Slacker CLI Environment Variables","text":"<p>The slacker CLI supports the following environment variables.</p> Name Description Default SLACKER_APP_NAME Name of the slacker Lambda function. <code>slacker</code>"},{"location":"04-installation-and-usage.html#cli-usage","title":"CLI Usage","text":"Command Usage <pre><code>usage: slacker [-h] [-v] {check,dump,get,list,put,restart,test} ...\n\nManage slacker webhooks and rules.\n\npositional arguments:\n  {check,dump,get,list,put,restart,test}\n    check           Check slacker configuration.\n    dump            Dump the DynamoDB webhooks table.\n    get             Fetch an entry from the DynamoDB webhooks table.\n    list            List source IDs in the DynamoDB webhooks table.\n    put             Create / update an entry in the DynamoDB webhooks table.\n    restart         Restart the slacker Lambda.\n    test            Test a message for processing against a webhooks entry.\n\noptions:\n  -h, --help        show this help message and exit\n  -v, --version     Show version and exit.\n\nFull user guide at https://jin-gizmo.github.io/slacker\n</code></pre> <p>Typical usage might be something like this:</p> <pre><code># Get help\nslacker --help\n# Get help on a subcommand\nslacker list --help\n\n# List webhooks table source IDs\nslacker list\n\n# Download one. Note that this will populate the `account` field in the\n# downloaded webhook data.\nslacker get my-source-id &gt; my-source-id.yaml\n\n# Test out the rules in a webhook file to see what they do to a message.\nslacker test my-source-id.yaml &lt; message.txt\n\n# Upload the webhooks entry back to DynamoDB but keep a backup of the original\nslacker put --backup my-source-id-orig.yaml my-source-id.yaml\n\n# Backup all webhooks to a zip file\nslacker dump webhooks.zip\n</code></pre>"},{"location":"04-installation-and-usage.html#adding-message-sources","title":"Adding Message Sources","text":"<p>Slacker supports messages received from:</p> <ul> <li>Amazon SNS</li> <li>CloudWatch Logs</li> <li>Amazon EventBridge</li> <li>Direct invocation of the slacker Lambda.</li> </ul> <p>Tip</p> <p>It is often easier to use the AWS Lambda console, rather than the console for the originating service when setting up Lambda triggers. The former seems to get the permissions correct more consistently. IMO.</p>"},{"location":"04-installation-and-usage.html#amazon-sns","title":"Amazon SNS","text":"<p>To add an SNS topic as a slacker message source:</p> <ol> <li>Create the SNS topic, if necessary, and get the topic ARN.</li> <li>Add the topic ARN as a trigger to the slacker Lambda.</li> <li>Create a new entry in the webhooks table with the     <code>sourceId</code> set to the topic ARN, and whatever destination Slack channel and     rules are appropriate.</li> </ol>"},{"location":"04-installation-and-usage.html#cloudwatch-logs","title":"CloudWatch Logs","text":"<p>To add a CloudWatch Log group as a slacker message source:</p> <ol> <li>Create the log group, if necessary.</li> <li>Add a subscription filter     to the log group. You can either add filtering at the log group level or in     the slacker rules. Note that CloudWatch only permits two subscription filters     per log group, which may limit your options.</li> <li>Create a new entry in the webhooks table with the     <code>sourceId</code> set to the log group name prefixed with <code>logs:</code>, and whatever     rules and destination Slack channel and rules are     appropriate.</li> </ol> <p>Warning</p> <p>Do not connect the slacker Lambda log group <code>/aws/lambda/slacker</code> as a slacker message source. Trust me on this, do not cross the streams.</p>"},{"location":"04-installation-and-usage.html#amazon-eventbridge","title":"Amazon EventBridge","text":"<p>Slacker can receive messages from Amazon EventBridge either directly, or via SNS. The target(s) for the EventBridge rule determine the path.</p>"},{"location":"04-installation-and-usage.html#eventbridge-rule-targets-without-input-transformation","title":"EventBridge Rule Targets without Input Transformation","text":"<p>If the EventBridge input message is to be sent to Slacker as-is (without an input transformation), it can either be sent directly with the slacker Lambda as a rule target, or via SNS. In the former case, slacker will use the message <code>source</code> attribute as the <code>sourceId</code> to lookup in the webhooks table. In the latter case, it uses the topic ARN as the <code>sourceId</code>.</p>"},{"location":"04-installation-and-usage.html#eventbridge-rule-targets-with-input-transformation","title":"EventBridge Rule Targets with Input Transformation","text":"<p>If the EventBridge rule is using an input transformation to create a new message, it can be sent to slacker via SNS. Messages received by slacker from SNS use the topic ARN as the <code>sourceId</code> to lookup in the webhooks table.</p> <p>Alternatively, an EventBridge rule with an input transformation can send a custom object directly to the slacker Lambda. In this case, slacker needs to know which webhooks entry to apply. The input template should include the following fields in the custom object for this purpose:</p> Name Required Type String SlackerSourceId Yes String The slacker <code>sourceId</code>. This is used as the key into the webhooks table to obtain the appropriate webhooks entry. SlackerSourceName No String A human readable description for the source. Defaults to the <code>SlackerSourceId</code>. <p>Refer to the AWS documentation for more information.</p>"},{"location":"04-installation-and-usage.html#direct-invocation","title":"Direct Invocation","text":"<p>Object messages can be sent directly to the slacker Lambda. The message should include the following fields for this purpose:</p> Name Required Type String SlackerSourceId Yes String The slacker <code>sourceId</code>. This is used as the key into the webhooks table to obtain the appropriate webhooks entry. SlackerSourceName No String A human readable description for the source. Defaults to the <code>SlackerSourceId</code>. <p>This example shows how to do it using the AWS CLI:</p> <pre><code>aws lambda invoke --function-name slacker response.json \\\n    --cli-binary-format raw-in-base64-out \\\n    --payload '\n{\n    \"SlackerSourceId\": \"my-source-id\",\n    \"SlackerSourceName\": \"My App\",\n    \"more\": \"data\",\n    \"...\": \"...\"\n}'\n</code></pre>"},{"location":"05-developing-message-rules.html","title":"Developing and Testing Message Rules","text":""},{"location":"05-developing-message-rules.html#developing-rules","title":"Developing Rules","text":"<p>Tips</p> <ol> <li> <p>When developing rules to handle a particular message type, the first     step is to obtain real samples of the message. A good way to do this is     to let slacker capture some initial events without any transformation.     These are handy for developing and testing rules.</p> </li> <li> <p>With careful use of the wildcard webhook, the     need to create new webhooks and rules can be minimised.</p> </li> </ol> <p>The recommended approach to developing rules is to write the webhooks table entries in YAML, under version control, and then test and deploy them with the slacker CLI.</p> <p>The webhook entry file can either be an existing entry that has been extracted from DynamoDB using <code>slacker get</code>, and then modified, or one created from scratch.</p> <p>JSON schema definitions are provided for webhooks and channels entries. This can make creating entries a lot easier in IDEs that support these (like the JetBrains suite), particularly for webhooks.</p> <p>The definitions are available at:</p> LatestVersioned <pre><code>https://jin-gizmo.github.io/slacker/schemas/latest/channel.schema.json\nhttps://jin-gizmo.github.io/slacker/schemas/latest/webhook.schema.json\n</code></pre> <pre><code>https://jin-gizmo.github.io/slacker/schemas/v2/channel.schema.json\nhttps://jin-gizmo.github.io/slacker/schemas/v2/webhook.schema.json\n</code></pre> <p>These schemas are referenced in the entries like so:</p> <pre><code>$schema: https://jin-gizmo.github.io/slacker/schemas/latest/webhook.schema.json\n</code></pre> <p>Note</p> <p>The slacker Lambda itself does not use the JSON schema for validation. It will do its best to work with an entry with minimal judgement. The <code>test</code> and <code>check</code> subcommands on the slacker CLI do perform schema validation.</p>"},{"location":"05-developing-message-rules.html#testing-rules","title":"Testing Rules","text":"<p>The slacker CLI provides the <code>test</code> subcommand that facilitates the process of experimenting with rules and messages to see how they will be treated. Usage is:</p> <pre><code>slacker test webhook-entry.yaml &lt; message.txt\n# ... or ...\nslacker test webhook-entry.yaml &lt; message.json\n</code></pre> <p>This will apply exactly the same processing to the test message as the slacker Lambda will, showing the resulting message that will be sent, if any. Additionally, full schema validation of the webhook entry will be performed.</p> <p>The message file will contain the actual message text that is sent (which slacker will decode as JSON if it can).</p> <p>For messages arriving via SNS, this does not include all of the delivery wrapping in which SNS embeds the message.  The <code>slacker test</code> subcommand requires the value of the <code>message</code> key from the SNS message, not the whole envelope.  The <code>message</code> field may be either a text message or an object if slacker has decoded a JSON blob.</p>"},{"location":"05-developing-message-rules.html#deploying-rules","title":"Deploying Rules","text":"<p>The slacker CLI provides the <code>put</code> subcommand that deploys webhook entries to the webhooks table. The following checks are made prior to upload:</p> <ul> <li>The AWS account number in the entry must match the target environment.</li> <li>A full schema verification of the webhook contents will be done.</li> </ul> <p>Usage is:</p> <pre><code>slacker put webhook-entry.yaml\n\n# To keep a backup of the previous entry...\nslacker put --backup webhook-entry-orig.yaml webhook-entry.yaml\n</code></pre> <p>Notes</p> <ol> <li>Slacker caches webhook entries for 5 minutes. Table updates can take     this amount of time to become effective. The duration can be changed by     setting the <code>SLACKER_CACHE_TTL</code>     environment variable. The <code>slacker restart</code> command can be used to     flush the caches.</li> <li>The DynamoDB tables have point-in-time recovery enabled, just in case.</li> </ol>"},{"location":"05-developing-message-rules.html#validating-webhook-entries","title":"Validating Webhook Entries","text":"<p>The slacker CLI is the primary tool for managing slacker table entries. It has a <code>check</code> subcommand that will perform a basic suite of configuration hygiene checks, looking for problems such as:</p> <ul> <li>Schema violations</li> <li>Webhooks that have odd combinations of <code>url</code> and <code>channel</code> keys</li> <li>Webhooks that reference channels that don't exist</li> <li>Webhooks with a <code>sourceId</code> that points to a resource that either doesn't     exist or isn't configured to send messages to slacker</li> <li>Unknown <code>sourceId</code> types</li> <li>SNS subscriptions to the slacker Lambda where either the SNS topic doesn't     exist or the corresponding webhook doesn't exist.</li> </ul> <pre><code>slacker check\n</code></pre>"},{"location":"06-rule-library.html","title":"Rule Library","text":"<p>This section provides some generic, reusable rules that may prove useful. Adjust them to suit your needs.</p> <p>In the examples, we have properly formatted any JSON in the source. In the absence of the slacker rule, this would appear in Slack as unreadable symbol soup. The chunky kind. With carrots.</p> <p>Note</p> <p>Some of the rules in the library may have overlapping scope. Bear in mind that the order of rules is significant, with the first matching rule being the only one that is applied. More specific rules should precede less specific ones.</p>"},{"location":"06-rule-library.html#aws-events","title":"AWS Events","text":"AWS Health Event MessageRuleResult <pre><code>{\n  \"version\": \"0\",\n  \"id\": \"f647f386-2347-6d6a-d4e9-d8d9ec36d810\",\n  \"detail-type\": \"AWS Health Event\",\n  \"source\": \"aws.health\",\n  \"account\": \"123456789012\",\n  \"time\": \"2024-11-30T05:35:14Z\",\n  \"region\": \"ap-southeast-2\",\n  \"resources\": [\n    \"FarGate01|service-01\",\n    \"FarGate01|service-02\",\n    \"FarGate01|service-03\"\n  ],\n  \"detail\": {\n    \"eventArn\": \"arn:aws:health:ap-southeast-2::event/ECS/AWS_ECS_TASK_PATCHING_RETIREMENT/AWS_ECS_TASK_PATCHING_RETIREMENT-SYD-DockerLinux-1-4-0-279-123456789012-MANAGED\",\n    \"service\": \"ECS\",\n    \"eventTypeCode\": \"AWS_ECS_TASK_PATCHING_RETIREMENT\",\n    \"eventTypeCategory\": \"scheduledChange\",\n    \"eventScopeCode\": \"ACCOUNT_SPECIFIC\",\n    \"communicationId\": \"334c2ec2523e1d02051ecc68e718394c9b95da96-1\",\n    \"startTime\": \"Sat, 7 Dec 2024 05:00:00 GMT\",\n    \"endTime\": \"Sat, 14 Dec 2024 05:00:00 GMT\",\n    \"lastUpdatedTime\": \"Sat, 30 Nov 2024 05:34:33 GMT\",\n    \"statusCode\": \"upcoming\",\n    \"eventRegion\": \"ap-southeast-2\",\n    \"eventDescription\": [\n      {\n        \"language\": \"en_US\",\n        \"latestDescription\": \"You are receiving this notification because AWS Fargate has deployed a new platform version revision (1) and will retire any tasks running on previous platform version revision(s) starting at Sat, 7 Dec 2024 05:00 GMT as part of routine task maintenance (2). Please find the list of affected tasks in the \\\\\\\"Affected Resources\\\\\\\" tab . There is no action required on your part unless you want to replace these tasks before task maintenance start time. When using the default value of 100% for minimum healthy percent configuration of an Amazon Elastic Container Service (Amazon ECS) service (3), a replacement task will be launched on the most recent platform version revision before the affected task is retired. Any tasks launched after Sat, 30 Nov 2024 05:00 GMT were launched on the new platform version revision.\\\\n\\\\nAWS Fargate is a serverless, pay-as-you-go compute engine that lets you focus on building applications without managing servers. As described in the Fargate documentation (2) and (4), Fargate regularly deploys platform version revisions to make new features available and for routine maintenance. The Fargate update includes updates to the underlying Operating System (Linux or Windows as applicable), and to runtime components. Fargate will gradually replace the tasks in your service using your configured deployment settings, ensuring all tasks run on the new Fargate platform version revision.\\\\n\\\\nWe do not expect this update to impact your ECS services. However, if you want to control when your tasks are replaced, you can initiate an ECS service update before Sat, 7 Dec 2024 05:00 GMT  by following the instructions below. \\\\n\\\\nIf you are using the rolling deployment type for your service, you can run the update-service command from the AWS command-line interface specifying force-new-deployment:\\\\n\\\\n$ aws ecs update-service --service service_name \\\\\\n--cluster cluster_name --force-new-deployment\\\\n\\\\nIf you are using the Blue/Green deployment type, please refer to the documentation for create-deployment (5) and create a new deployment using the same task definition version.\\\\n\\\\nPlease contact AWS Support (6) if you have any questions or concerns.\\\\n\\\\n(1) https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform-fargate.html\\\\n(2) https://docs.aws.amazon.com/AmazonECS/latest/userguide/task-maintenance.html\\\\n(3) https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service_definition_parameters.html#sd-deploymentconfiguration \\\\n(4) https://aws.amazon.com/blogs/containers/improving-operational-visibility-with-aws-fargate-task-retirement-notifications/\\\\n(5) https://docs.aws.amazon.com/cli/latest/reference/deploy/create-deployment.html\\\\n(6) https://aws.amazon.com/support\\\\n\\\\n\"\n      }\n    ],\n    \"affectedEntities\": [\n      {\n        \"entityValue\": \"FarGate01|service-01\",\n        \"status\": \"IMPAIRED\",\n        \"lastUpdatedTime\": \"Sat, 30 Nov 2024 05:34:33 GMT\"\n      },\n      {\n        \"entityValue\": \"FarGate01|service-02\",\n        \"status\": \"IMPAIRED\",\n        \"lastUpdatedTime\": \"Sat, 30 Nov 2024 05:34:33 GMT\"\n      },\n      {\n        \"entityValue\": \"FarGate01|service-03\",\n        \"status\": \"IMPAIRED\",\n        \"lastUpdatedTime\": \"Sat, 30 Nov 2024 05:34:33 GMT\"\n      }\n    ],\n    \"affectedAccount\": \"123456789012\",\n    \"page\": \"1\",\n    \"totalPages\": \"1\"\n  }\n}\n</code></pre> <pre><code>rules:\n  - '#': AWS Health Event\n    if: \"{{ data['detail-type'] == 'AWS Health Event' }}\"\n    template: &gt;-\n      {% set icons = {\n         'scheduledChange': ':calendar:',\n         'issue': ':zap:',\n         'accountNotification': ':information_source:',\n         'investigation': ':magnifying_glass_right:',\n       } %}\n      {%- set sep=':black_small_square:' -%}\n      {{ icons.get(data.detail.eventTypeCategory, ':large_purple_circle:') }}\n      *{{ data.detail.eventTypeCode }}*\n      {{ sep }}\n      {{ data.detail.eventTypeCategory }}\n\n      *{{ data.detail.startTime }} ... {{ data.detail.endTime }}*\n\n      {% if data.resources -%}\n      ```\n\n      {% for resource in data.resources %}\n      * {{ resource }}\n\n      {% endfor -%}\n      ```\n      {% endif %}\n\n      {{ (data.detail.eventDescription | first).latestDescription | replace('\\\\n', '\\n')  }}\n</code></pre>"},{"location":"06-rule-library.html#cloudwatch-alarms","title":"CloudWatch Alarms","text":"<p>A core use case for slacker is to reformat CloudWatch alarm messages delivered via SNS into something readable.</p> <p>Some alarms will naturally be sent to a paging service, but it's almost always worth mirroring them in Slack. Also, a lot of alarms reveal something interesting about the environment without being serious enough to page someone.</p> CloudWatch Generic Alarm On MessageRuleResult <pre><code>{\n  \"AlarmName\": \"my-sqs-queue-depth\",\n  \"AlarmDescription\": \"Too many messages queued for my-sqs-queue\",\n  \"AWSAccountId\": \"123456789012\",\n  \"AlarmConfigurationUpdatedTimestamp\": \"2023-04-19T05:17:32.984+0000\",\n  \"NewStateValue\": \"ALARM\",\n  \"NewStateReason\": \"Threshold Crossed: 30 out of the last 30 datapoints were greater than the threshold (20.0). The most recent datapoints which crossed the threshold: [60.0 (06/12/24 05:34:00), 60.0 (06/12/24 05:33:00), 59.0 (06/12/24 05:32:00), 59.0 (06/12/24 05:31:00), 59.0 (06/12/24 05:30:00)] (minimum 30 datapoints for OK -&gt; ALARM transition).\",\n  \"StateChangeTime\": \"2024-12-06T05:36:35.649+0000\",\n  \"Region\": \"Asia Pacific (Sydney)\",\n  \"AlarmArn\": \"arn:aws:cloudwatch:ap-southeast-2:123456789012:alarm:my-sqs-queue-queue-depth\",\n  \"OldStateValue\": \"OK\",\n  \"OKActions\": [\n    \"arn:aws:sns:ap-southeast-2:123456789012:slacker-demo\"\n  ],\n  \"AlarmActions\": [\n    \"arn:aws:sns:ap-southeast-2:123456789012:slacker-demo\"\n  ],\n  \"InsufficientDataActions\": [],\n  \"Trigger\": {\n    \"MetricName\": \"ApproximateNumberOfMessagesVisible\",\n    \"Namespace\": \"AWS/SQS\",\n    \"StatisticType\": \"Statistic\",\n    \"Statistic\": \"MAXIMUM\",\n    \"Unit\": null,\n    \"Dimensions\": [\n      {\n        \"value\": \"my-sqs-queue\",\n        \"name\": \"QueueName\"\n      }\n    ],\n    \"Period\": 60,\n    \"EvaluationPeriods\": 30,\n    \"DatapointsToAlarm\": 30,\n    \"ComparisonOperator\": \"GreaterThanThreshold\",\n    \"Threshold\": 20.0,\n    \"TreatMissingData\": \"ignore\",\n    \"EvaluateLowSampleCountPercentile\": \"\"\n  }\n}\n</code></pre> <pre><code>rules:\n  - '#': CloudWatch Alarm ON\n    if: \"{{ data.NewStateValue == 'ALARM' }}\"\n    colour: '#ff0000'\n    preamble: &lt;!channel&gt;\n    template: &gt;\n      {%- set sep=':black_small_square:' -%}\n      {%- set desc=(data.AlarmDescription or data.AlarmName or '?').splitlines() -%}\n\n      :red_circle:\n      *{{ desc[0].strip() }}*\n      {{ sep }}\n      {{ data.StateChangeTime.split('.')[0] }}Z\n      {%- if desc | length &gt; 1 %}\n\n\n      {{ data.AlarmDescription }}{%endif %}\n\n\n      _{{ data.NewStateReason }}_\n</code></pre> <p></p> CloudWatch Generic Alarm Off MessageRuleResult <pre><code>{\n  \"AlarmName\": \"my-sqs-queue-depth\",\n  \"AlarmDescription\": \"Too many messages queued for my-sqs-queue\",\n  \"AWSAccountId\": \"123456789012\",\n  \"AlarmConfigurationUpdatedTimestamp\": \"2024-11-19T23:16:17.097+0000\",\n  \"NewStateValue\": \"OK\",\n  \"NewStateReason\": \"Threshold Crossed: 1 out of the last 50 datapoints [48.0 (04/12/24 00:34:00)] was not greater than the threshold (50.0) (minimum 1 datapoint for ALARM -&gt; OK transition).\",\n  \"StateChangeTime\": \"2024-12-04T00:36:01.796+0000\",\n  \"Region\": \"Asia Pacific (Sydney)\",\n  \"AlarmArn\": \"arn:aws:cloudwatch:ap-southeast-2:123456789012:alarm:my-sqs-queue-queue-depth\",\n  \"OldStateValue\": \"ALARM\",\n  \"OKActions\": [\n    \"arn:aws:sns:ap-southeast-2:123456789012:slacker-demo\"\n  ],\n  \"AlarmActions\": [\n    \"arn:aws:sns:ap-southeast-2:123456789012:slacker-demo\"\n  ],\n  \"InsufficientDataActions\": [],\n  \"Trigger\": {\n    \"MetricName\": \"ApproximateNumberOfMessagesVisible\",\n    \"Namespace\": \"AWS/SQS\",\n    \"StatisticType\": \"Statistic\",\n    \"Statistic\": \"MAXIMUM\",\n    \"Unit\": null,\n    \"Dimensions\": [\n      {\n        \"value\": \"my-sqs-queue\",\n        \"name\": \"QueueName\"\n      }\n    ],\n    \"Period\": 60,\n    \"EvaluationPeriods\": 50,\n    \"DatapointsToAlarm\": 50,\n    \"ComparisonOperator\": \"GreaterThanThreshold\",\n    \"Threshold\": 50.0,\n    \"TreatMissingData\": \"ignore\",\n    \"EvaluateLowSampleCountPercentile\": \"\"\n  }\n}\n</code></pre> <pre><code>rules:\n  - '#': CloudWatch Alarm OFF\n    if: \"{{ data.NewStateValue == 'OK' }}\"\n    colour: '#00ff00'\n    template: &gt;\n      {%- set sep=':black_small_square:' -%}\n      {%- set desc=(data.AlarmDescription or data.AlarmName or '?').splitlines() -%}\n\n      :white_check_mark:\n      *{{ desc[0].strip() }}*\n      {{ sep }}\n      {{ data.StateChangeTime.split('.')[0] }}Z\n</code></pre> <p></p> CloudWatch API Gateway Alarm On <p>This variant on the generic CloudWatch alarm is specific to API Gateway related alarms. It needs to be placed earlier in the rules than the generic CloudWatch alarm rule.</p> MessageRuleResult <pre><code>{\n  \"AlarmName\": \"my-portal-api-4XX-error\",\n  \"AlarmDescription\": \"Api gateway my-portal-api 4XX error more than 50 for 10 minutes. Observation required. More information: https://jin-gizmo.github.io\",\n  \"AWSAccountId\": \"123456789012\",\n  \"AlarmConfigurationUpdatedTimestamp\": \"2024-04-18T00:31:54.519+0000\",\n  \"NewStateValue\": \"ALARM\",\n  \"NewStateReason\": \"Threshold Crossed: 2 out of the last 2 datapoints [63.0 (11/12/24 06:04:00), 66.0 (11/12/24 05:59:00)] were greater than the threshold (50.0) (minimum 2 datapoints for OK -&gt; ALARM transition).\",\n  \"StateChangeTime\": \"2024-12-11T06:09:47.192+0000\",\n  \"Region\": \"Asia Pacific (Sydney)\",\n  \"AlarmArn\": \"arn:aws:cloudwatch:ap-southeast-2:123456789012:alarm:my-portal-api-4XX-error\",\n  \"OldStateValue\": \"OK\",\n  \"OKActions\": [],\n  \"AlarmActions\": [\n    \"arn:aws:sns:ap-southeast-2:123456789012:slacker-demo\"\n  ],\n  \"InsufficientDataActions\": [],\n  \"Trigger\": {\n    \"MetricName\": \"4XXError\",\n    \"Namespace\": \"AWS/ApiGateway\",\n    \"StatisticType\": \"Statistic\",\n    \"Statistic\": \"SUM\",\n    \"Unit\": null,\n    \"Dimensions\": [\n      {\n        \"value\": \"my-portal-api\",\n        \"name\": \"ApiName\"\n      }\n    ],\n    \"Period\": 300,\n    \"EvaluationPeriods\": 2,\n    \"DatapointsToAlarm\": 2,\n    \"ComparisonOperator\": \"GreaterThanThreshold\",\n    \"Threshold\": 50.0,\n    \"TreatMissingData\": \"notBreaching\",\n    \"EvaluateLowSampleCountPercentile\": \"\"\n  }\n}\n</code></pre> <pre><code>rules:\n  - '#': CloudWatch Alarm ON (API Gateway Alarm)\n    if: \"{{ data.NewStateValue == 'ALARM' and data.Trigger.Namespace == 'AWS/ApiGateway' }}\"\n    colour: '#ff0000'\n    preamble: &lt;!channel&gt;\n    template: &gt;\n      {%- set sep=':black_small_square:' -%}\n      {#- Get the API name from alarm dimensions -#}\n      {%- set api=(data.Trigger.Dimensions | selectattr('name', 'equalto', 'ApiName') | first) or {'value': '?'} -%}\n      {#- Get a Python re.Match object for the event counts from the alarm reason -#}\n      {%- set m=re.search('\\[[^]]*\\]', data.NewStateReason) -%}\n\n      :red_circle:\n      *{{ data.AlarmName }}*\n      {{ sep }}\n      {{ api.value }}\n      {{ sep }}\n      {{ data.StateChangeTime.split('.')[0] }}Z\n\n\n      {% if m -%}\n      {#- Get rid of the timetamps in the clause containing event counts -#}\n      {%- set counts=re.sub(' *\\([^)]*\\)','',m.group(0)) -%}\n      *Count {{ counts }} &gt; {{ data.Trigger.Threshold | int }}*{% endif %}\n      {%- if data.AlarmDescription %}\n\n\n      _{{ data.AlarmDescription }}_{% endif %}\n</code></pre> <p></p>"},{"location":"06-rule-library.html#ec2-events","title":"EC2 Events","text":"Auto Scaling Instance Launch <p>These events occur when an auto scaling group launches new instances. It is sometimes handy to know about this but rarely interesting enough to page someone. What is not handy is 50 lines of JSON bumph spewing into your operations Slack channel when an instance launches.</p> <p>Slacker is a good fit for these messages.</p> MessageRuleResult <pre><code>{\n  \"Origin\": \"EC2\",\n  \"Destination\": \"AutoScalingGroup\",\n  \"Progress\": 50,\n  \"AccountId\": \"123456789012\",\n  \"Description\": \"Launching a new EC2 instance: i-01918b2230392f631\",\n  \"RequestId\": \"59864e62-e212-6604-627d-5ac06f09f7ec\",\n  \"EndTime\": \"2024-12-05T21:27:35.517Z\",\n  \"AutoScalingGroupARN\": \"arn:aws:autoscaling:ap-southeast-2:123456789012:autoScalingGroup:8dc6c859-8cbd-4549-94f1-72678f7a5a0a:autoScalingGroupName/my-asg\",\n  \"ActivityId\": \"59864e62-e212-6604-627d-5ac06f09f7ec\",\n  \"StartTime\": \"2024-12-05T21:27:29.689Z\",\n  \"Service\": \"AWS Auto Scaling\",\n  \"Time\": \"2024-12-05T21:27:35.517Z\",\n  \"EC2InstanceId\": \"i-01918b2230392f631\",\n  \"StatusCode\": \"InProgress\",\n  \"StatusMessage\": \"\",\n  \"Details\": {\n    \"Subnet ID\": \"subnet-abcdefab\",\n    \"Availability Zone\": \"ap-southeast-2b\",\n    \"InvokingAlarms\": [\n      {\n        \"AlarmArn\": \"arn:aws:cloudwatch:ap-southeast-2:123456789012:alarm:TargetTracking-my-asg-AlarmHigh-1bd75141-14b2-4f14-ad2b-6d26ea7c94a8\",\n        \"Trigger\": {\n          \"MetricName\": \"WorkerBacklog\",\n          \"EvaluateLowSampleCountPercentile\": \"\",\n          \"ComparisonOperator\": \"GreaterThanThreshold\",\n          \"TreatMissingData\": \"\",\n          \"Statistic\": \"AVERAGE\",\n          \"StatisticType\": \"Statistic\",\n          \"Period\": 60,\n          \"EvaluationPeriods\": 3,\n          \"Unit\": null,\n          \"Namespace\": \"MyApp\",\n          \"Threshold\": 20\n        },\n        \"AlarmName\": \"TargetTracking-my-asg-AlarmHigh-1bd75141-14b2-4f14-ad2b-6d26ea7c94a8\",\n        \"AlarmDescription\": \"DO NOT EDIT OR DELETE. For TargetTrackingScaling policy arn:aws:autoscaling:ap-southeast-2:123456789012:scalingPolicy:a2c49e03-5a24-4a34-93a6-4d1aab48ad6d:autoScalingGroupName/my-asg:policyName/my-asg-asgWorkerScalingPolicy-crdTF9\",\n        \"AWSAccountId\": \"123456789012\",\n        \"OldStateValue\": \"ALARM\",\n        \"Region\": \"Asia Pacific (Sydney)\",\n        \"NewStateValue\": \"ALARM\",\n        \"AlarmConfigurationUpdatedTimestamp\": 1732249141214,\n        \"StateChangeTime\": 1733433742189\n      }\n    ]\n  },\n  \"AutoScalingGroupName\": \"my-asg\",\n  \"Cause\": \"At 2024-12-05T21:27:22Z a monitor alarm TargetTracking-my-asg-AlarmHigh-1bd75141-14b2-4f14-ad2b-6d26ea7c94a8 in state ALARM triggered policy my-asg-asgWorkerScalingPolicy-crdTF9lGieul changing the desired capacity from 2 to 3.  At 2024-12-05T21:27:28Z an instance was started in response to a difference between desired and actual capacity, increasing the capacity from 2 to 3.\",\n  \"Event\": \"autoscaling:EC2_INSTANCE_LAUNCH\"\n}\n</code></pre> <p>The same rule handles both launch and termination events.</p> <pre><code>rules:\n  - '#': Auto scaling launch / termination\n    if: \"{{ data.Service == 'AWS Auto Scaling' }}\"\n    template: &gt;\n      {% set icons = {\n        'autoscaling:EC2_INSTANCE_LAUNCH': ':arrow_heading_up:',\n        'autoscaling:EC2_INSTANCE_TERMINATE': ':arrow_heading_down:',\n      } %}\n      {%- set sep = ':black_small_square:' -%}\n      {{- icons.get(data.Event, data.Event.split(':')[-1]) }}\n      *{{ data.AutoScalingGroupName }}*\n      {{ sep }}\n      {{ data.EC2InstanceId }}\n      {{ sep }}\n      {{ data.StartTime.split('.')[0] }}Z\n\n      _{{ data.StatusCode }}_\n</code></pre> <p></p> Auto Scaling Instance Termination MessageRuleResult <pre><code>{\n  \"Origin\": \"AutoScalingGroup\",\n  \"Destination\": \"EC2\",\n  \"Progress\": 60,\n  \"AccountId\": \"123456789012\",\n  \"Description\": \"Terminating EC2 instance: i-0bc09f781ddd6f516\",\n  \"RequestId\": \"f6c642e2-21ec-4bcb-a28e-892808bfa29e\",\n  \"EndTime\": \"2024-12-05T21:50:47.987Z\",\n  \"AutoScalingGroupARN\": \"arn:aws:autoscaling:ap-southeast-2:123456789012:autoScalingGroup:8dc6c859-8cbd-4549-94f1-72678f7a5a0a:autoScalingGroupName/my-asg\",\n  \"ActivityId\": \"f6c642e2-21ec-4bcb-a28e-892808bfa29e\",\n  \"StartTime\": \"2024-12-05T21:48:52.881Z\",\n  \"Service\": \"AWS Auto Scaling\",\n  \"Time\": \"2024-12-05T21:50:47.988Z\",\n  \"EC2InstanceId\": \"i-0bc09f781ddd6f516\",\n  \"StatusCode\": \"MidTerminatingLifecycleAction\",\n  \"StatusMessage\": \"\",\n  \"Details\": {\n    \"Subnet ID\": \"subnet-abcdefab\",\n    \"Availability Zone\": \"ap-southeast-2c\",\n    \"InvokingAlarms\": [\n      {\n        \"AlarmArn\": \"arn:aws:cloudwatch:ap-southeast-2:123456789012:alarm:TargetTracking-my-asg-AlarmLow-7a95c75c-aaf8-482d-9516-90723ad7ea91\",\n        \"Trigger\": {\n          \"MetricName\": \"WorkerBacklog\",\n          \"EvaluateLowSampleCountPercentile\": \"\",\n          \"ComparisonOperator\": \"LessThanThreshold\",\n          \"TreatMissingData\": \"\",\n          \"Statistic\": \"AVERAGE\",\n          \"StatisticType\": \"Statistic\",\n          \"Period\": 60,\n          \"EvaluationPeriods\": 15,\n          \"Unit\": null,\n          \"Namespace\": \"MyApp\",\n          \"Threshold\": 14\n        },\n        \"AlarmName\": \"TargetTracking-my-asg-AlarmLow-7a95c75c-aaf8-482d-9516-90723ad7ea91\",\n        \"AlarmDescription\": \"DO NOT EDIT OR DELETE. For TargetTrackingScaling policy arn:aws:autoscaling:ap-southeast-2:123456789012:scalingPolicy:a2c49e03-5a24-4a34-93a6-4d1aab48ad6d:autoScalingGroupName/my-asg:policyName/my-asg-asgWorkerScalingPolicy-crdTF9\",\n        \"AWSAccountId\": \"123456789012\",\n        \"OldStateValue\": \"ALARM\",\n        \"Region\": \"Asia Pacific (Sydney)\",\n        \"NewStateValue\": \"ALARM\",\n        \"AlarmConfigurationUpdatedTimestamp\": 1732250795584,\n        \"StateChangeTime\": 1733435027153\n      }\n    ]\n  },\n  \"AutoScalingGroupName\": \"my-asg\",\n  \"Cause\": \"At 2024-12-05T21:48:47Z a monitor alarm TargetTracking-my-asg-AlarmLow-7a95c75c-aaf8-482d-9516-90723ad7ea91 in state ALARM triggered policy my-asg-asgWorkerScalingPolicy-crdTF9lGieul changing the desired capacity from 2 to 1.  At 2024-12-05T21:48:52Z an instance was taken out of service in response to a difference between desired and actual capacity, shrinking the capacity from 2 to 1.  At 2024-12-05T21:48:52Z instance i-0bc09f781ddd6f516 was selected for termination.\",\n  \"Event\": \"autoscaling:EC2_INSTANCE_TERMINATE\"\n}\n</code></pre> <p>The same rule is used to handle both auto scaling launches and terminations.</p> <p></p>"},{"location":"06-rule-library.html#general-purpose-rules","title":"General Purpose Rules","text":"JSON Formatting <p>Lot's of AWS events show up in (densely packed) JSON format. A handy rule of last resort simply formats the JSON nicely before passing it to Slack.</p> <p>This rule should generally go low in the rules list. It will not touch messages that are not JSON.</p> MessageRuleResult <pre><code>{\"a\": \"alpha\", \"c\": \"gamma\", \"b\": \"beta\", \"...\":[\"d\", \"e\", \"etc\"]}\n</code></pre> <pre><code>rules:\n  - '#': Pretty print messages consisting of JSON\n    template: |\n      ```\n      {{ data | tojson(4) }}\n      ```\n</code></pre> <p></p> Wildcard Webhook Rules <p>The wildcard webhook is a special purpose webhooks table entry with a <code>sourceId</code> of <code>*</code>. Any rules in the wildcard webhook are implicitly added to the end of the rules list for all other webhooks. It is a good place for common rules that would otherwise need to be duplicated in individual webhooks.</p> <p>The following sample can be modified as needed.</p> Rule <pre><code>sourceId: '*'\nrules:\n  - '#': AWS Health Event\n    if: \"{{ data['detail-type'] == 'AWS Health Event' }}\"\n    template: &gt;-\n      {% set icons = {\n         'scheduledChange': ':calendar:',\n         'issue': ':zap:',\n         'accountNotification': ':information_source:',\n         'investigation': ':magnifying_glass_right:',\n       } %}\n      {%- set sep=':black_small_square:' -%}\n      {{ icons.get(data.detail.eventTypeCategory, ':large_purple_circle:') }}\n      *{{ data.detail.eventTypeCode }}*\n      {{ sep }}\n      {{ data.detail.eventTypeCategory }}\n\n      *{{ data.detail.startTime }} ... {{ data.detail.endTime }}*\n\n      {% if data.resources -%}\n      ```\n\n      {% for resource in data.resources %}\n      * {{ resource }}\n\n      {% endfor -%}\n      ```\n      {% endif %}\n\n      {{ (data.detail.eventDescription | first).latestDescription | replace('\\\\n', '\\n')  }}\n\n  - '#': CloudWatch Alarm ON\n    if: \"{{ data.NewStateValue == 'ALARM' }}\"\n    colour: '#ff0000'\n    preamble: &lt;!channel&gt;\n    template: &gt;\n      {%- set sep=':black_small_square:' -%}\n      {%- set desc=(data.AlarmDescription or data.AlarmName or '?').splitlines() -%}\n\n      :red_circle:\n      *{{ desc[0].strip() }}*\n      {{ sep }}\n      {{ data.StateChangeTime.split('.')[0] }}Z\n      {%- if desc | length &gt; 1 %}\n\n\n      {{ data.AlarmDescription }}{%endif %}\n\n\n      _{{ data.NewStateReason }}_\n\n  - '#': CloudWatch Alarm OFF\n    if: \"{{ data.NewStateValue == 'OK' }}\"\n    colour: '#00ff00'\n    template: &gt;\n      {%- set sep=':black_small_square:' -%}\n      {%- set desc=(data.AlarmDescription or data.AlarmName or '?').splitlines() -%}\n\n      :white_check_mark:\n      *{{ desc[0].strip() }}*\n      {{ sep }}\n      {{ data.StateChangeTime.split('.')[0] }}Z\n\n  - '#': Pretty print messages consisting of JSON\n    template: |\n      ```\n      {{ data | tojson(4) }}\n      ```\n</code></pre>"},{"location":"07-release-notes.html","title":"Release Notes","text":""},{"location":"07-release-notes.html#version-2","title":"Version 2","text":""},{"location":"07-release-notes.html#version-260","title":"Version 2.6.0","text":"<p>This version is functionally compatible with v2.5 insofar as the main code is concerned. A number of incremental functional enhancements have been made. Changes have also been made to elements of packaging, deployment and documentation.</p> <p>Changes are:</p> <ul> <li> <p>Slacker now supports direct messages from Amazon EventBridge as well as     direct invocation of the slacker Lambda.</p> </li> <li> <p>Introduced the wildcard webhook. This serves two     purposes:</p> <ol> <li>Webhook of last resort: If an incoming message has a source ID that     doesn't match any entry in the webhooks table,     the wildcard webhook is used to process the message.</li> <li>Container for common webhook rules: Any rules in the wildcard webhook     are implicitly appended to the rules of all other webhooks.</li> </ol> </li> <li> <p>The following changes have been made to the slacker CLI:</p> <ul> <li>The <code>slacker check</code> command now does full schema validation on     webhooks items.     See Testing Rules for more information.</li> <li>The <code>slacker get</code> command now does syntax colouring when the output is     to a terminal.</li> <li>The <code>slacker restart</code> command has been added to restart the slacker     Lambda. This will clear the caches holding DynamoDB entries.</li> </ul> </li> <li> <p>AWS SAM is now used for installation, rather than raw CloudFormation. Not     totally convinced that's a real step forward but it's done.</p> </li> <li> <p>Some extra information, examples and the elementary     rule library, have been added into this user guide.     Contributions welcome.</p> </li> <li> <p>JSON schema definitions are now provided for webhooks     and channels entries. This can make creating entries     a lot easier in IDEs that support these (like the JetBrains suite).</p> </li> </ul>"}]}